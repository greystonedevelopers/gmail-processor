package gmailprocessor

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"github.com/phires/go-guerrilla/backends"
	_ "github.com/phires/go-guerrilla/backends"
	"github.com/phires/go-guerrilla/mail"
	"github.com/phires/go-guerrilla/response"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/gmail/v1"
	"google.golang.org/api/option"
	"os"
	"strings"
	"time"
)

// ----------------------------------------------------------------------------------
// Processor Name: gmail
// ----------------------------------------------------------------------------------
// Description   : Acts as an SMTP to Google mail bridge
//
//
// ----------------------------------------------------------------------------------
// Config Options: set in the backend_config section
//
//	: sa_key - string - after you create your service account download the file and supply it as eg: gsgmailapi-9e49eeb1e33c.json
//	: mail_sender - string - use this as the mail account you want to send from in google suite.
//						     eg printer@greystonetec.co.za
//					         make sure in the google admin under the security you sent the "domain wide deligation"
//					         client account and scope permissions
//	: mail_scopes - string - set this as your scopes list see point above.
//							 example https://mail.google.com/ defined in // import "google.golang.org/api/gmail/v1
//  : save_process - string - backend processes to call example -  HeadersParser|Header|Hasher|Gmail|Debugger
// --------------:-------------------------------------------------------------------
// Input         : envelope
//
//	: e.DeliveryHeader generated by ParseHeader() processor
//	: e.MailFrom
//	: e.Subject - generated by by ParseHeader() processor
//
// ----------------------------------------------------------------------------------
// Output        : Sets e.QueuedId with the first item fromHashes[0]
//				   Uses the google api to forward mails
// ----------------------------------------------------------------------------------

type GmailProcessorConfig struct {
	SAKey                 string `json:"sa_key"`
	MailSender            string `json:"mail_sender"`
	MailScopes            string `json:"mail_scopes"`
	UseOriginalMail       bool   `json:"use_original_mail"`
	AdditionalBodyMessage string `json:"additional_body_message"`
	SaveDebugMails        bool   `json:"save_debug_mails"`
}

type GmailProcessor struct {
	config  *GmailProcessorConfig
	SAKey   []byte
	Service *gmail.Service
}

// ProcessSpecialCase you need to have a body else gmail will throw it. see printer_message.txt
func (g *GmailProcessor) ProcessSpecialCase(e *mail.Envelope) []byte {
	bufferModified := bytes.NewBuffer(e.Data.Bytes())

	contentTypeHeader := e.Header.Get("Content-Type")

	if strings.Contains(strings.ToLower(contentTypeHeader), "multipart/mixed") {
		contentTypeHeaderParts := strings.Split(contentTypeHeader, ";")
		for _, part := range contentTypeHeaderParts {
			if strings.Contains(part, "boundary=") {
				foundBody := false
				boundary := strings.Split(part, "=")[1]
				boundary = strings.ReplaceAll(boundary, "\"", "")

				// look for the boundry and the content type text/plain or text/html
				boundaryRecords := strings.Split(bufferModified.String(), "--"+boundary)

				for _, record := range boundaryRecords {
					backends.Log().Debug(record)
					if strings.Contains(record, "Content-Type: text/plain") {
						backends.Log().Debugf("found header: %s", record)
						foundBody = true
						break
					}
				}
				addedBody := bytes.NewBuffer(make([]byte, 0))
				if !foundBody {
					// we need to add a body. Lets see if we add it to the end.
					addedBody.WriteString("\r\n")
					addedBody.WriteString("--" + strings.ReplaceAll(boundary, "\"", ""))
					addedBody.WriteString("\r\n")
					addedBody.WriteString("Content-Type: text/plain; charset=\"us-ascii\"")
					addedBody.WriteString("\r\n")
					addedBody.WriteString("\r\n")
					addedBody.WriteString(g.config.AdditionalBodyMessage)
					addedBody.WriteString("\r\n")
					// rebuild
					bufferModified.Reset()
					for index, record := range boundaryRecords {
						if index == 0 {
							bufferModified.WriteString(record)
							bufferModified.WriteString(addedBody.String())
						} else {
							bufferModified.WriteString("\r\n")
							bufferModified.WriteString("--" + strings.ReplaceAll(boundary, "\"", ""))
							bufferModified.WriteString(record)
						}
					}
				}
			}
		}
	}
	if g.config.SaveDebugMails {
		os.WriteFile("mail.txt", bufferModified.Bytes(), 0644)
	}
	return bufferModified.Bytes()
}

func (googleMail *GmailProcessor) loadCredentialsFromFile() error {
	// Load the service account key
	data, errFile := os.ReadFile(googleMail.config.SAKey)
	if errFile != nil {
		return errFile
	}
	googleMail.SAKey = data
	mailScopes := strings.Split(googleMail.config.MailScopes, ",")
	/*
		[]string{
					gmail.MailGoogleComScope,
					//googleMail.GmailComposeScope, // add additional scopes as needed
					//googleMail.MailGoogleComScope,
					//googleMail.GmailMetadataScope,
				}
	*/

	params := google.CredentialsParams{
		Subject: googleMail.config.MailSender,
		Scopes:  mailScopes,
	}

	// Create a service account credentials object
	credentials, errCredentials := google.CredentialsFromJSONWithParams(context.Background(), data, params)
	if errCredentials != nil {
		return errCredentials
	}

	// Create the Gmail service
	srv, err := gmail.NewService(context.Background(), option.WithCredentials(credentials))
	if err != nil {
		backends.Log().Warningf("Error creating Gmail service: %v", err)
	}
	googleMail.Service = srv
	return nil
}

var Processor = func() backends.Decorator {
	var config *GmailProcessorConfig
	s := &GmailProcessor{}

	// open the database connection (it will also check if we can select the table)
	backends.Svc.AddInitializer(backends.InitializeWith(func(backendConfig backends.BackendConfig) error {
		configType := backends.BaseConfig(&GmailProcessorConfig{})
		bcfg, err := backends.Svc.ExtractConfig(backendConfig, configType)
		if err != nil {
			return err
		}
		config = bcfg.(*GmailProcessorConfig)
		s.config = config
		errLoadingCredentials := s.loadCredentialsFromFile()
		if errLoadingCredentials != nil {
			return errLoadingCredentials
		} else {
			backends.Log().Infof("Loaded credentials from file: %s", config.SAKey)
		}
		return nil
	}))

	// shutdown will close the database connection
	backends.Svc.AddShutdowner(backends.ShutdownWith(func() error {
		return nil
	}))

	return func(p backends.Processor) backends.Processor {
		return backends.ProcessWith(func(e *mail.Envelope, task backends.SelectTask) (backends.Result, error) {
			switch task {
			case backends.TaskSaveMail:
				hash := ""
				if len(e.Hashes) > 0 {
					hash = e.Hashes[0]
					e.QueuedId = e.Hashes[0]
				}
				backends.Log().Infof("Hash: %s ", hash)
				var encodedMessage string

				if s.config.SaveDebugMails {
					file, errCreate := os.Create(fmt.Sprintf("mailrx_%s.txt", time.Now().Format("20060102150405")))
					if errCreate != nil {
						return backends.NewResult(response.Canned.FailBackendTimeout), errCreate
					}

					file.Write(e.Data.Bytes())
					file.Close()
				}

				gmailMsg := new(gmail.Message)
				if s.config.UseOriginalMail {
					encodedMessage = base64.URLEncoding.EncodeToString(e.Data.Bytes())
				} else {
					encodedMessage = base64.URLEncoding.EncodeToString(s.ProcessSpecialCase(e))
				}
				gmailMsg.Raw = encodedMessage
				googleMessage, errSendMail := s.Service.Users.Messages.Send("me", gmailMsg).Do()
				if errSendMail != nil {
					if googleMessage != nil {
						backends.Log().Debugf("%v", googleMessage)
					}
					backends.Log().Errorf("Error sending mail: %v", errSendMail)
					return backends.NewResult(response.Canned.FailBackendTimeout), errSendMail
				}
			default:
				panic("unhandled default case")
			}
			// next processor
			return p.Process(e, task)
		})
	}
}
