package gmailprocessor

import (
	"context"
	"encoding/base64"
	"github.com/phires/go-guerrilla/backends"
	_ "github.com/phires/go-guerrilla/backends"
	"github.com/phires/go-guerrilla/mail"
	"github.com/phires/go-guerrilla/response"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/gmail/v1"
	"google.golang.org/api/option"
	"os"
	"strings"
)

// ----------------------------------------------------------------------------------
// Processor Name: gmail
// ----------------------------------------------------------------------------------
// Description   : Acts as an SMTP to Google mail bridge
//
//
// ----------------------------------------------------------------------------------
// Config Options: set in the backend_config section
//
//	: sa_key - string - after you create your service account download the file and supply it as eg: gsgmailapi-9e49eeb1e33c.json
//	: mail_sender - string - use this as the mail account you want to send from in google suite.
//						     eg printer@greystonetec.co.za
//					         make sure in the google admin under the security you sent the "domain wide deligation"
//					         client account and scope permissions
//	: mail_scopes - string - set this as your scopes list see point above.
//							 example https://mail.google.com/ defined in // import "google.golang.org/api/gmail/v1
//  : save_process - string - backend processes to call example -  HeadersParser|Header|Hasher|Gmail|Debugger
// --------------:-------------------------------------------------------------------
// Input         : envelope
//
//	: e.DeliveryHeader generated by ParseHeader() processor
//	: e.MailFrom
//	: e.Subject - generated by by ParseHeader() processor
//
// ----------------------------------------------------------------------------------
// Output        : Sets e.QueuedId with the first item fromHashes[0]
//				   Uses the google api to forward mails
// ----------------------------------------------------------------------------------

type GmailProcessorConfig struct {
	SAKey      string `json:"sa_key"`
	MailSender string `json:"mail_sender"`
	MailScopes string `json:"mail_scopes"`
}

type GmailProcessor struct {
	config  *GmailProcessorConfig
	SAKey   []byte
	Service *gmail.Service
}

func (googleMail *GmailProcessor) loadCredentialsFromFile() error {
	// Load the service account key
	data, errFile := os.ReadFile(googleMail.config.SAKey)
	if errFile != nil {
		return errFile
	}
	googleMail.SAKey = data
	mailScopes := strings.Split(googleMail.config.MailScopes, ",")
	/*
		[]string{
					gmail.MailGoogleComScope,
					//googleMail.GmailComposeScope, // add additional scopes as needed
					//googleMail.MailGoogleComScope,
					//googleMail.GmailMetadataScope,
				}
	*/

	params := google.CredentialsParams{
		Subject: googleMail.config.MailSender,
		Scopes:  mailScopes,
	}

	// Create a service account credentials object
	credentials, errCredentials := google.CredentialsFromJSONWithParams(context.Background(), data, params)
	if errCredentials != nil {
		return errCredentials
	}

	// Create the Gmail service
	srv, err := gmail.NewService(context.Background(), option.WithCredentials(credentials))
	if err != nil {
		backends.Log().Warningf("Error creating Gmail service: %v", err)
	}
	googleMail.Service = srv
	return nil
}

func Gmail() backends.Decorator {
	var config *GmailProcessorConfig
	s := &GmailProcessor{}

	// open the database connection (it will also check if we can select the table)
	backends.Svc.AddInitializer(backends.InitializeWith(func(backendConfig backends.BackendConfig) error {
		configType := backends.BaseConfig(&GmailProcessorConfig{})
		bcfg, err := backends.Svc.ExtractConfig(backendConfig, configType)
		if err != nil {
			return err
		}
		config = bcfg.(*GmailProcessorConfig)
		s.config = config
		errLoadingCredentials := s.loadCredentialsFromFile()
		if errLoadingCredentials != nil {
			return errLoadingCredentials
		} else {
			backends.Log().Infof("Loaded credentials from file: %s", config.SAKey)
		}
		return nil
	}))

	// shutdown will close the database connection
	backends.Svc.AddShutdowner(backends.ShutdownWith(func() error {
		return nil
	}))

	return func(p backends.Processor) backends.Processor {
		return backends.ProcessWith(func(e *mail.Envelope, task backends.SelectTask) (backends.Result, error) {
			switch task {
			case backends.TaskSaveMail:
				hash := ""
				if len(e.Hashes) > 0 {
					hash = e.Hashes[0]
					e.QueuedId = e.Hashes[0]
				}
				backends.Log().Infof("Hash: %s ", hash)

				msg := new(gmail.Message)
				encodedMessage := base64.URLEncoding.EncodeToString(e.Data.Bytes())
				msg.Raw = encodedMessage
				//backends.Log().Info(encodedMessage)

				_, errSendMail := s.Service.Users.Messages.Send("me", msg).Do()
				if errSendMail != nil {
					backends.Log().Errorf("Error sending mail: %v", errSendMail)
					return backends.NewResult(response.Canned.FailBackendTimeout), errSendMail
				}
			default:
				panic("unhandled default case")
			}
			// next processor
			return p.Process(e, task)
		})
	}
}
