package gmailprocessor

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"github.com/phires/go-guerrilla/backends"
	_ "github.com/phires/go-guerrilla/backends"
	"github.com/phires/go-guerrilla/mail"
	"github.com/phires/go-guerrilla/response"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/gmail/v1"
	"google.golang.org/api/option"
	"os"
	"strings"
	"time"
)

// ----------------------------------------------------------------------------------
// Processor Name: gmail
// ----------------------------------------------------------------------------------
// Description   : Acts as an SMTP to Google mail bridge
//
//
// ----------------------------------------------------------------------------------
// Config Options: set in the backend_config section
//
//	: sa_key - string - after you create your service account download the file and supply it as eg: gsgmailapi-9e49eeb1e33c.json
//	: mail_sender - string - use this as the mail account you want to send from in google suite.
//						     eg printer@greystonetec.co.za
//					         make sure in the google admin under the security you sent the "domain wide deligation"
//					         client account and scope permissions
//	: mail_scopes - string - set this as your scopes list see point above.
//							 example https://mail.google.com/ defined in // import "google.golang.org/api/gmail/v1
//  : save_process - string - backend processes to call example -  HeadersParser|Header|Hasher|Gmail|Debugger
// --------------:-------------------------------------------------------------------
// Input         : envelope
//
//	: e.DeliveryHeader generated by ParseHeader() processor
//	: e.MailFrom
//	: e.Subject - generated by by ParseHeader() processor
//
// ----------------------------------------------------------------------------------
// Output        : Sets e.QueuedId with the first item fromHashes[0]
//				   Uses the google api to forward mails
// ----------------------------------------------------------------------------------

type GmailProcessorConfig struct {
	SAKey           string `json:"sa_key"`
	MailSender      string `json:"mail_sender"`
	MailScopes      string `json:"mail_scopes"`
	UseOriginalMail bool   `json:"use_original_mail"`
}

type GmailProcessor struct {
	config  *GmailProcessorConfig
	SAKey   []byte
	Service *gmail.Service
}

// ProcessSpecialCase you need to have a body else gmail will throw it. see printer_message.txt
func (g *GmailProcessor) ProcessSpecialCase(e *mail.Envelope) []byte {
	bytestr := bytes.NewBuffer(make([]byte, 0))
	//bytestr.WriteString(fmt.Sprintf("Subject: %s", e.Header.Get("Subject")))
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString(fmt.Sprintf("Sender: %s", e.Header.Get("Sender")))
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString(fmt.Sprintf("From: %s", e.Header.Get("From")))
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString(fmt.Sprintf("Date: %s", e.Header.Get("Date")))
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString(fmt.Sprintf("To: %s", e.Header.Get("To")))
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString(fmt.Sprintf("Message-ID: %s", e.Header.Get("Message-Id")))
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString(fmt.Sprintf("MIME-Version: %s", e.Header.Get("MIME-Version")))
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString(fmt.Sprintf("Content-Type: %s", "multipart/mixed; boundary=\"=-zwG7Bugek9MSdvyfOxkt\"")) //e.Header.Get("Content-Type")))
	//bytestr.WriteString("\r\n")
	////bytestr.WriteString(fmt.Sprintf("Content-Transfer-Encoding: %s", e.Header.Get("Content-Transfer-Encoding")))
	////bytestr.WriteString("\r\n")
	//bytestr.WriteString("\r\n")
	////bytestr.WriteString("--KONICA_MINOLTA_Internet_Fax_Boundary")
	//
	//bytestr.WriteString("--=-zwG7Bugek9MSdvyfOxkt")
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString("Content-Type: application/pdf; ")
	//bytestr.WriteString("name=\"SKMBT_C364e25052208080.pdf")
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString("Content-Disposition: attachment; ")
	//bytestr.WriteString("filename=\"SKMBT_C364e25052208080.pdf\"")
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString("Content-Transfer-Encoding: base64")
	//bytestr.WriteString("\r\n")
	//bytestr.WriteString("\r\n")

	fileData, errRead := os.ReadFile("printer_message.txt")
	//	fileData, errRead := os.ReadFile("mailrx_20250523091422.txt")
	if errRead != nil {
		backends.Log().Errorf("Error reading file: %v", errRead)
	}
	bytestr.Write(fileData)

	//bytestr.WriteString("hello world")
	//bytestr.WriteString("\r\n")
	os.WriteFile("mail.txt", bytestr.Bytes(), 0644)

	return bytestr.Bytes()
}

func (googleMail *GmailProcessor) loadCredentialsFromFile() error {
	// Load the service account key
	data, errFile := os.ReadFile(googleMail.config.SAKey)
	if errFile != nil {
		return errFile
	}
	googleMail.SAKey = data
	mailScopes := strings.Split(googleMail.config.MailScopes, ",")
	/*
		[]string{
					gmail.MailGoogleComScope,
					//googleMail.GmailComposeScope, // add additional scopes as needed
					//googleMail.MailGoogleComScope,
					//googleMail.GmailMetadataScope,
				}
	*/

	params := google.CredentialsParams{
		Subject: googleMail.config.MailSender,
		Scopes:  mailScopes,
	}

	// Create a service account credentials object
	credentials, errCredentials := google.CredentialsFromJSONWithParams(context.Background(), data, params)
	if errCredentials != nil {
		return errCredentials
	}

	// Create the Gmail service
	srv, err := gmail.NewService(context.Background(), option.WithCredentials(credentials))
	if err != nil {
		backends.Log().Warningf("Error creating Gmail service: %v", err)
	}
	googleMail.Service = srv
	return nil
}

var Processor = func() backends.Decorator {
	var config *GmailProcessorConfig
	s := &GmailProcessor{}

	// open the database connection (it will also check if we can select the table)
	backends.Svc.AddInitializer(backends.InitializeWith(func(backendConfig backends.BackendConfig) error {
		configType := backends.BaseConfig(&GmailProcessorConfig{})
		bcfg, err := backends.Svc.ExtractConfig(backendConfig, configType)
		if err != nil {
			return err
		}
		config = bcfg.(*GmailProcessorConfig)
		s.config = config
		errLoadingCredentials := s.loadCredentialsFromFile()
		if errLoadingCredentials != nil {
			return errLoadingCredentials
		} else {
			backends.Log().Infof("Loaded credentials from file: %s", config.SAKey)
		}
		return nil
	}))

	// shutdown will close the database connection
	backends.Svc.AddShutdowner(backends.ShutdownWith(func() error {
		return nil
	}))

	return func(p backends.Processor) backends.Processor {
		return backends.ProcessWith(func(e *mail.Envelope, task backends.SelectTask) (backends.Result, error) {
			switch task {
			case backends.TaskSaveMail:
				hash := ""
				if len(e.Hashes) > 0 {
					hash = e.Hashes[0]
					e.QueuedId = e.Hashes[0]
				}
				backends.Log().Infof("Hash: %s ", hash)
				var encodedMessage string

				file, errCreate := os.Create(fmt.Sprintf("mailrx_%s.txt", time.Now().Format("20060102150405")))
				if errCreate != nil {
					return backends.NewResult(response.Canned.FailBackendTimeout), errCreate
				}

				file.Write(e.Data.Bytes())
				file.Close()

				gmailMsg := new(gmail.Message)
				if s.config.UseOriginalMail {
					encodedMessage = base64.URLEncoding.EncodeToString(e.Data.Bytes())
				} else {
					encodedMessage = base64.URLEncoding.EncodeToString(s.ProcessSpecialCase(e))
				}
				gmailMsg.Raw = encodedMessage
				googleMessage, errSendMail := s.Service.Users.Messages.Send("me", gmailMsg).Do()
				if errSendMail != nil {
					if googleMessage != nil {
						backends.Log().Debugf("%v", googleMessage)
					}
					backends.Log().Errorf("Error sending mail: %v", errSendMail)
					return backends.NewResult(response.Canned.FailBackendTimeout), errSendMail
				}
			default:
				panic("unhandled default case")
			}
			// next processor
			return p.Process(e, task)
		})
	}
}
